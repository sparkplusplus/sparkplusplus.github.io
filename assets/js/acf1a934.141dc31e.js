"use strict";(self.webpackChunkdocs_4=self.webpackChunkdocs_4||[]).push([[687],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>c});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},d=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},h="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),h=p(a),m=i,c=h["".concat(l,".").concat(m)]||h[m]||u[m]||r;return a?n.createElement(c,o(o({ref:t},d),{},{components:a})):n.createElement(c,o({ref:t},d))}));function c(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,o=new Array(r);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[h]="string"==typeof e?e:i,o[1]=s;for(var p=2;p<r;p++)o[p]=a[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},4755:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var n=a(7462),i=(a(7294),a(3905));const r={title:"Shuffle Details",sidebar_position:4,id:"shuffle-details",description:"Prophecy deployment is flexible and supports multiple mechanisms",tags:["overview","spark-internals"]},o="Shuffle Process",s={unversionedId:"spark-internals/shuffle-details",id:"spark-internals/shuffle-details",title:"Shuffle Details",description:"Prophecy deployment is flexible and supports multiple mechanisms",source:"@site/docs/spark-internals/shuffleDetails.md",sourceDirName:"spark-internals",slug:"/spark-internals/shuffle-details",permalink:"/spark-internals/shuffle-details",draft:!1,editUrl:"https://github.com/sparkplusplus/sparkplusplus.github.io/edit/main/docs/spark-internals/shuffleDetails.md",tags:[{label:"overview",permalink:"/tags/overview"},{label:"spark-internals",permalink:"/tags/spark-internals"}],version:"current",sidebarPosition:4,frontMatter:{title:"Shuffle Details",sidebar_position:4,id:"shuffle-details",description:"Prophecy deployment is flexible and supports multiple mechanisms",tags:["overview","spark-internals"]},sidebar:"defaultSidebar",previous:{title:"Spark Physical Plan",permalink:"/spark-internals/plans/spark-physical-plan"},next:{title:"Architecture",permalink:"/spark-internals/architecture"}},l={},p=[{value:"Shuffle Comparison between Hadoop and Spark",id:"shuffle-comparison-between-hadoop-and-spark",level:2},{value:"Shuffle Write",id:"shuffle-write",level:2},{value:"Shuffle Read",id:"shuffle-read",level:2},{value:"Shuffle Read of Typical Transformations",id:"shuffle-read-of-typical-transformations",level:2},{value:"<code>reduceByKey(func)</code>",id:"reducebykeyfunc",level:3},{value:"<code>groupByKey(numPartitions)</code>",id:"groupbykeynumpartitions",level:3},{value:"<code>distinct(numPartitions)</code>",id:"distinctnumpartitions",level:3},{value:"<code>cogroup(otherRDD, numPartitions)</code>",id:"cogroupotherrdd-numpartitions",level:3},{value:"<code>intersection(otherRDD)</code> and <code>join(otherRDD, numPartitions)</code>",id:"intersectionotherrdd-and-joinotherrdd-numpartitions",level:3},{value:"sortByKey(ascending, numPartition)",id:"sortbykeyascending-numpartition",level:3},{value:"<code>coalesce(numPartitions, shuffle = true)</code>",id:"coalescenumpartitions-shuffle--true",level:3},{value:"HashMap in Shuffle Read",id:"hashmap-in-shuffle-read",level:2},{value:"<code>AppendOnlyMap</code>",id:"appendonlymap",level:3},{value:"<code>ExternalAppendOnlyMap</code>",id:"externalappendonlymap",level:3},{value:"Discussion",id:"discussion",level:2}],d={toc:p},h="wrapper";function u(e){let{components:t,...r}=e;return(0,i.kt)(h,(0,n.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"shuffle-process"},"Shuffle Process"),(0,i.kt)("p",null,"Previously we've discussed Spark's physical plan and its execution details. But one thing is left untouched: ",(0,i.kt)("strong",{parentName:"p"},"how data gets through a ",(0,i.kt)("inlineCode",{parentName:"strong"},"ShuffleDependency")," to the next stage?")),(0,i.kt)("h2",{id:"shuffle-comparison-between-hadoop-and-spark"},"Shuffle Comparison between Hadoop and Spark"),(0,i.kt)("p",null,"There're some differences and also similarities between the shuffle process in Hadoop and in Spark:"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"From a high-level point of view, they are similar.")," They both partition the mapper's (or ",(0,i.kt)("inlineCode",{parentName:"p"},"ShuffleMapTask")," in Spark) output and send each partition to its corresponding reducer (in Spark, it could be a ",(0,i.kt)("inlineCode",{parentName:"p"},"ShuffleMapTask")," in the next stage, or a ",(0,i.kt)("inlineCode",{parentName:"p"},"ResultTask"),"). The reducer buffers the data in memory, shuffles and aggregates the data, and applies the ",(0,i.kt)("inlineCode",{parentName:"p"},"reduce()")," logic once the data is aggregated."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"From a low-level point of view, there're quite a few differences.")," The shuffle in Hadoop is sort-based since the records must be sorted before ",(0,i.kt)("inlineCode",{parentName:"p"},"combine()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"reduce()"),". The sort can be done by an external sort algorithm thus allowing ",(0,i.kt)("inlineCode",{parentName:"p"},"combine()")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"reduce()")," to tackle very large datasets. Currently in Spark the default shuffle process is hash-based. Usually it uses a ",(0,i.kt)("inlineCode",{parentName:"p"},"HashMap")," to aggregate the shuffle data and no sort is applied. If the data needs to be sorted, user has to call ",(0,i.kt)("inlineCode",{parentName:"p"},"sortByKey()")," explicitly. In Spark 1.1, we can set the configuration ",(0,i.kt)("inlineCode",{parentName:"p"},"spark.shuffle.manager")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"sort")," to enable sort-based shuffle. In Spark 1.2, the default shuffle process will be sort-based."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Implementation-wise, there're also differences.")," As we know, there are obvious steps in a Hadoop workflow: ",(0,i.kt)("inlineCode",{parentName:"p"},"map()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"spill"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"merge"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"shuffle"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"sort")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"reduce()"),". Each step has a predefined responsibility and it fits the procedural programming model well. However in Spark, there're no such fixed steps, instead we have stages and a series of transformations. So operations like ",(0,i.kt)("inlineCode",{parentName:"p"},"spill"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"merge")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"aggregate")," need to be somehow included in the transformations."),(0,i.kt)("p",null,'If we name the mapper side process of partitioning and persisting data "shuffle write", and the reducer side reading and aggregating data "shuffle read". Then the problem becomes: ',(0,i.kt)("strong",{parentName:"p"},"How to integrate shuffle write and shuffle read logic in Spark's logical or physical plan? How to implement shuffle write and shuffle read efficiently?")),(0,i.kt)("h2",{id:"shuffle-write"},"Shuffle Write"),(0,i.kt)("p",null,"Shuffle write is a relatively simple task if a sorted output is not required. It partitions and persists the data. The persistance of data here has two advantages: reducing heap pressure and enhancing fault-tolerance."),(0,i.kt)("p",null,"Its implementation is simple: add the shuffle write logic at the end of ",(0,i.kt)("inlineCode",{parentName:"p"},"ShuffleMapStage")," (in which there's a ",(0,i.kt)("inlineCode",{parentName:"p"},"ShuffleMapTask"),"). Each output record of the final RDD in this stage is partitioned and persisted, as shown in the following diagram:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"shuffle-write-no-consolidation",src:a(8343).Z,width:"2164",height:"1264"})),(0,i.kt)("p",null,"In the diagram there're 4 ",(0,i.kt)("inlineCode",{parentName:"p"},"ShuffleMapTask"),"s to execute in the same worker node with 2 cores. The task result (records of the final RDD in the stage) is written on the local disk (data persistence). Each task has ",(0,i.kt)("inlineCode",{parentName:"p"},"R")," buffers, ",(0,i.kt)("inlineCode",{parentName:"p"},"R")," equals the number of reducers (the number if tasks in the next stage). The buffers are called buckets in Spark. By default the size of each bucket is 32KB (100KB before Spark 1.1) and is configurable by ",(0,i.kt)("inlineCode",{parentName:"p"},"spark.shuffle.file.buffer.kb")," ."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"In fact bucket is a general concept in Spark that represents the location of the partitioned output of a ",(0,i.kt)("inlineCode",{parentName:"p"},"ShuffleMapTask"),". Here for simplicity a bucket is referred to an in-memory buffer.")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"ShuffleMapTask")," employs the pipelining techinque to compute the result records of the final RDD. Each record is sent to the bucket of its corresponding partition, which is determined by ",(0,i.kt)("inlineCode",{parentName:"p"},"partitioner.partition(record.getKey())"),". The content of these buckets is written continuously to local disk files called ",(0,i.kt)("inlineCode",{parentName:"p"},"ShuffleBlockFile"),", or ",(0,i.kt)("inlineCode",{parentName:"p"},"FileSegment")," for short. Reducers will fetch their ",(0,i.kt)("inlineCode",{parentName:"p"},"FileSegment")," in shuffle read phase."),(0,i.kt)("p",null,"An implementation like this is very simple, but has some issues:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"We may produce too many ",(0,i.kt)("inlineCode",{parentName:"strong"},"FileSegment"),".")," Each ",(0,i.kt)("inlineCode",{parentName:"li"},"ShuffleMapTask")," produces ",(0,i.kt)("inlineCode",{parentName:"li"},"R"),"(number of reducers) ",(0,i.kt)("inlineCode",{parentName:"li"},"FileSegment"),", so ",(0,i.kt)("inlineCode",{parentName:"li"},"M")," ",(0,i.kt)("inlineCode",{parentName:"li"},"ShuffleMapTask")," will produce ",(0,i.kt)("inlineCode",{parentName:"li"},"M * R")," files. For big datasets we could have big ",(0,i.kt)("inlineCode",{parentName:"li"},"M")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"R"),", as a result there may be lots of intermediate data files."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Buffers could take a lot of space.")," On a worker node, we could have ",(0,i.kt)("inlineCode",{parentName:"li"},"R * M")," buckets for each core available to Spark. Spark will reuse the buffer space after a ",(0,i.kt)("inlineCode",{parentName:"li"},"ShuffleMapTask")," but there could still be ",(0,i.kt)("inlineCode",{parentName:"li"},"R * cores")," buckets in memory. On a node with 8 cores processing a 1000-reducer job, buckets will take up 256MB (",(0,i.kt)("inlineCode",{parentName:"li"},"R * cores * 32KB"),").")),(0,i.kt)("p",null,"Currently, there's no good solution to the second problem. We need to write buffers anyway and if they're too small there will be impact on IO speed. For the first problem, we have a file consolidation solution already implemented in Spark. Let's check it out:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"shuffle-write-consolidation",src:a(4360).Z,width:"1752",height:"1358"})),(0,i.kt)("p",null,"It's clear that from the above diagram, consecutive ",(0,i.kt)("inlineCode",{parentName:"p"},"ShuffleMapTask"),"s running on the same core share a shuffle file. Each task appends its output data, ",(0,i.kt)("inlineCode",{parentName:"p"},"ShuffleBlock")," i', after the output data of the previous task, ",(0,i.kt)("inlineCode",{parentName:"p"},"ShuffleBlock")," i. A ",(0,i.kt)("inlineCode",{parentName:"p"},"ShuffleBlock")," is called a ",(0,i.kt)("inlineCode",{parentName:"p"},"FileSegment"),". In this way, reducers in the next stage can just fetch the whole file and we reduce the number of files needed in each worker node to ",(0,i.kt)("inlineCode",{parentName:"p"},"cores * R"),". File consolidation feature can be activated by setting ",(0,i.kt)("inlineCode",{parentName:"p"},"spark.shuffle.consolidateFiles")," to true."),(0,i.kt)("h2",{id:"shuffle-read"},"Shuffle Read"),(0,i.kt)("p",null,"Let's check a physical plan of ",(0,i.kt)("inlineCode",{parentName:"p"},"reduceBykey"),", which contains ",(0,i.kt)("inlineCode",{parentName:"p"},"ShuffleDependency"),":"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"reduceByKey",src:a(3721).Z,width:"1733",height:"1247"})),(0,i.kt)("p",null,"Intuitively, we need to fetch the data of ",(0,i.kt)("inlineCode",{parentName:"p"},"MapPartitionRDD")," to be able to evaluate ",(0,i.kt)("inlineCode",{parentName:"p"},"ShuffleRDD"),". Then come the problems:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"When to fetch? Fetch for each ",(0,i.kt)("inlineCode",{parentName:"li"},"ShuffleMapTask")," or fetch only once after all ",(0,i.kt)("inlineCode",{parentName:"li"},"ShuffleMapTask"),"s are done?"),(0,i.kt)("li",{parentName:"ul"},"Fetch and process the records at the same time or fetch and then process?"),(0,i.kt)("li",{parentName:"ul"},"Where to store the fetched data?"),(0,i.kt)("li",{parentName:"ul"},"How do the tasks of the next stage know the location of the fetched data?")),(0,i.kt)("p",null,"Solutions in Spark:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"When to fetch?")," Wait after all ",(0,i.kt)("inlineCode",{parentName:"p"},"ShuffleMapTask"),"s end and then fetch. We know that a stage will be executed only after its parent stages are executed, so it's intuitive that the fetch operation begins after all ",(0,i.kt)("inlineCode",{parentName:"p"},"ShuffleMapTask"),"s in the previous stage are done. The fetched ",(0,i.kt)("inlineCode",{parentName:"p"},"FileSegments")," have to be buffered in memory, so we can't fetch too much before the buffer content is written to disk. Spark limits this buffer size by ",(0,i.kt)("inlineCode",{parentName:"p"},"spark.reducer.maxMbInFlight"),", here we name it ",(0,i.kt)("inlineCode",{parentName:"p"},"softBuffer"),". It has default size 48MB. A ",(0,i.kt)("inlineCode",{parentName:"p"},"softBuffer")," usually contains multiple fetched ",(0,i.kt)("inlineCode",{parentName:"p"},"FileSegments"),". But sometimes one single segment can fill up the buffer.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Fetch and process the records at the same time or fetch and then process?")," Fetch and process the records at the same time. In MapReduce, the shuffle stage fetches the data and then applies ",(0,i.kt)("inlineCode",{parentName:"p"},"combine()")," logic at the same time. However in MapReduce the reducer input data needs to be sorted, so the ",(0,i.kt)("inlineCode",{parentName:"p"},"reduce()")," logic is applied after the shuffle-sort process. Since Spark does not require a sorted order for the reducer input data, we don't need to wait until all the data gets fetched to start processing. ",(0,i.kt)("strong",{parentName:"p"},"Then how Spark implements this shuffle and processing?")," In fact Spark utilizes data structures like HashMap to do the job. Each \\<Key, Value",">"," pair from the shuffle process is inserted into a HashMap. If the ",(0,i.kt)("inlineCode",{parentName:"p"},"Key")," is already present, then the pair is aggregated by ",(0,i.kt)("inlineCode",{parentName:"p"},"func(hashMap.get(Key), Value)"),". In the above WordCount example, the ",(0,i.kt)("inlineCode",{parentName:"p"},"func")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"hashMap.get(Key) + Value"),", and its result is updated in the HashMap. This ",(0,i.kt)("inlineCode",{parentName:"p"},"func")," has a similar role to ",(0,i.kt)("inlineCode",{parentName:"p"},"reduce()")," in Hadoop, but they differ in details. We illustrate the difference by the following code snippet:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"// MapReduce\nreduce(K key, Iterable<V> values) {\n    result = process(key, values)\n    return result\n}\n\n// Spark\nreduce(K key, Iterable<V> values) {\n    result = null\n    for (V value : values)\n        result  = func(result, value)\n    return result\n}\n")))),(0,i.kt)("p",null,"In Hadoop MapReduce, we can define any data structure we like in ",(0,i.kt)("inlineCode",{parentName:"p"},"process")," function. It's just a function that takes an ",(0,i.kt)("inlineCode",{parentName:"p"},"Iterable")," as parameter. We can also choose to cache the ",(0,i.kt)("inlineCode",{parentName:"p"},"values")," for further processing. In Spark, a ",(0,i.kt)("inlineCode",{parentName:"p"},"foldLeft")," like technique is used to apply the ",(0,i.kt)("inlineCode",{parentName:"p"},"func"),". For example, in Hadoop, it's very easy to compute the average out of ",(0,i.kt)("inlineCode",{parentName:"p"},"values"),": ",(0,i.kt)("inlineCode",{parentName:"p"},"sum(values) / values.length"),". But it's not the case in the Spark model. We'll come back to this part later."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Where to store the fetched data?")," The fetched ",(0,i.kt)("inlineCode",{parentName:"p"},"FileSegment"),"s get buffered in ",(0,i.kt)("inlineCode",{parentName:"p"},"softBuffer"),". Then the data is processed, and written to a configurable location. If ",(0,i.kt)("inlineCode",{parentName:"p"},"spark.shuffle.spill")," is false, then the write location is only memory. A special data structure, ",(0,i.kt)("inlineCode",{parentName:"p"},"AppendOnlyMap"),", is used to hold these processed data in memory. Otherwise, the processed data will be written to memory and disk, using ",(0,i.kt)("inlineCode",{parentName:"p"},"ExternalAppendOnlyMap"),". This data structure can spill the sorted key-value pairs on disk when there isn't enough memory available. ",(0,i.kt)("strong",{parentName:"p"},"A key problem in using both memory and disk is how to find a balance of the two.")," In Hadoop, by default 70% of the memory is reserved for shuffle data. Once 66% of this part of the memory is used, Hadoop starts the merge-combine-spill process. In Spark a similar strategy is used. We'll talk about its details later in this chapter.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"How do the tasks of the next stage know the location of the fetched data?")," Recall that in the last chapter, there's an important step: ",(0,i.kt)("inlineCode",{parentName:"p"},"ShuffleMapStage"),", which will register its final RDD by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"MapOutputTrackerMaster.registerShuffle(shuffleId, rdd.partitions.size)"),". So during the shuffle process, reducers get the data location by querying ",(0,i.kt)("inlineCode",{parentName:"p"},"MapOutputTrackerMaster")," in the driver process. When a ",(0,i.kt)("inlineCode",{parentName:"p"},"ShuffleMapTask")," finishes, it will report the location of its ",(0,i.kt)("inlineCode",{parentName:"p"},"FileSegment")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"MapOutputTrackerMaster"),"."))),(0,i.kt)("p",null,"Now we have discussed the main ideas behind shuffle write and shuffle read as well as some implementation details. Let's dive into some interesting details."),(0,i.kt)("h2",{id:"shuffle-read-of-typical-transformations"},"Shuffle Read of Typical Transformations"),(0,i.kt)("h3",{id:"reducebykeyfunc"},(0,i.kt)("inlineCode",{parentName:"h3"},"reduceByKey(func)")),(0,i.kt)("p",null,"We have briefly talked about the fetch and reduce process of ",(0,i.kt)("inlineCode",{parentName:"p"},"reduceByKey()"),". Note that for an RDD, not all its data is present in the memory at a given time. The processing is always on a record basis. Processed record is rejected if possible. On a record level perspective, the ",(0,i.kt)("inlineCode",{parentName:"p"},"reduce()")," logic can be shown as below:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"shuffle-reduce",src:a(9018).Z,width:"598",height:"416"})),(0,i.kt)("p",null,"We can see that the fetched records are aggregated using a HashMap, and once all the records are aggregated, we will have the result. The ",(0,i.kt)("inlineCode",{parentName:"p"},"func")," needs to be commutative."),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"mapPartitionsWithContext")," operation is used to transform the ",(0,i.kt)("inlineCode",{parentName:"p"},"ShuffledRDD")," to a ",(0,i.kt)("inlineCode",{parentName:"p"},"MapPartitionsRDD"),"."),(0,i.kt)("p",null,"To reduce network trafic between nodes, we could use map side ",(0,i.kt)("inlineCode",{parentName:"p"},"combine()")," in Hadoop. It's also feasible in Spark. All we need is to apply the ",(0,i.kt)("inlineCode",{parentName:"p"},"mapPartitionsWithContext")," in the ",(0,i.kt)("inlineCode",{parentName:"p"},"ShuffleMapStage"),". For example in ",(0,i.kt)("inlineCode",{parentName:"p"},"reduceByKey")," , the transformation of ",(0,i.kt)("inlineCode",{parentName:"p"},"ParallelCollectionRDD")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"MapPartitionsRDD")," is equivalent to a map side combine."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Comparison between map()->reduce() in Hadoop and ",(0,i.kt)("inlineCode",{parentName:"strong"},"reduceByKey")," in Spark")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"map side: there's no difference on the map side. For ",(0,i.kt)("inlineCode",{parentName:"li"},"combine()")," logic, Hadoop imposes a sort before ",(0,i.kt)("inlineCode",{parentName:"li"},"combine()"),". Spark applies the ",(0,i.kt)("inlineCode",{parentName:"li"},"combine()")," logic by using a hash map."),(0,i.kt)("li",{parentName:"ul"},"reduce side: Shuffle process in Hadoop will fetch the data until a certain amount, then applies ",(0,i.kt)("inlineCode",{parentName:"li"},"combine()")," logic, then merge sort the data to feed the ",(0,i.kt)("inlineCode",{parentName:"li"},"reduce()")," function. In Spark fetch and reduce is done at the same time (in a hash map), so the reduce function needs to be commutative.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Comparison in terms of memory usage")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"map side: Hadoop needs a big, circular buffer to hold and sort the ",(0,i.kt)("inlineCode",{parentName:"li"},"map()")," output data. But ",(0,i.kt)("inlineCode",{parentName:"li"},"combine()")," does not need extra space. Spark needs a hash map to do ",(0,i.kt)("inlineCode",{parentName:"li"},"combine()"),". And persisting records to local disk needs buffers (buckets)."),(0,i.kt)("li",{parentName:"ul"},"reduce side: Hadoop needs some memory space to store shuffled data. ",(0,i.kt)("inlineCode",{parentName:"li"},"combine()")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"reduce()")," require no extra space since their input is sorted and can be grouped and then aggregated. In Spark, a ",(0,i.kt)("inlineCode",{parentName:"li"},"softBuffer")," is needed for fetching. A hash map is used for storing the result of ",(0,i.kt)("inlineCode",{parentName:"li"},"combine()")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"reduce()"),", if only memory is used in processing data. However, part of the data can be stored on disk if configured to use both memory and disk.")),(0,i.kt)("h3",{id:"groupbykeynumpartitions"},(0,i.kt)("inlineCode",{parentName:"h3"},"groupByKey(numPartitions)")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"ShuffleGroupByKey",src:a(8801).Z,width:"522",height:"284"})),(0,i.kt)("p",null,"The process is similar to that of ",(0,i.kt)("inlineCode",{parentName:"p"},"reduceByKey()"),". The ",(0,i.kt)("inlineCode",{parentName:"p"},"func")," becomes ",(0,i.kt)("inlineCode",{parentName:"p"},"result = result ++ record.value"),". This means that each key's values are grouped together without further aggregation."),(0,i.kt)("h3",{id:"distinctnumpartitions"},(0,i.kt)("inlineCode",{parentName:"h3"},"distinct(numPartitions)")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"ShuffleDistinct",src:a(2855).Z,width:"1633",height:"610"})),(0,i.kt)("p",null,"Similar to ",(0,i.kt)("inlineCode",{parentName:"p"},"reduceByKey()"),". The ",(0,i.kt)("inlineCode",{parentName:"p"},"func")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"result = result == null ? record.value : result"),". This means that we check the existence of the record in the ",(0,i.kt)("inlineCode",{parentName:"p"},"HashMap"),". If it exists, reject the record, otherwise insert it into the map. Like ",(0,i.kt)("inlineCode",{parentName:"p"},"reduceByKey()"),", there's map side ",(0,i.kt)("inlineCode",{parentName:"p"},"combine()"),"."),(0,i.kt)("h3",{id:"cogroupotherrdd-numpartitions"},(0,i.kt)("inlineCode",{parentName:"h3"},"cogroup(otherRDD, numPartitions)")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"ShuffleCoGroup",src:a(1787).Z,width:"535",height:"419"})),(0,i.kt)("p",null,"There could be 0, 1 or multiple ",(0,i.kt)("inlineCode",{parentName:"p"},"ShuffleDependency")," for a ",(0,i.kt)("inlineCode",{parentName:"p"},"CoGroupedRDD"),". But in the shuffle process we don't create a hash map for each shuffle dependency, but one hash map for all of them. Different from ",(0,i.kt)("inlineCode",{parentName:"p"},"reduceByKey"),", the hash map is constructed in RDD's ",(0,i.kt)("inlineCode",{parentName:"p"},"compute()")," rather than in ",(0,i.kt)("inlineCode",{parentName:"p"},"mapPartitionsWithContext()"),"."),(0,i.kt)("p",null,"A task of this RDD's execution will allocate an ",(0,i.kt)("inlineCode",{parentName:"p"},"Array[ArrayBuffer]"),". This array contains the same number of empty ",(0,i.kt)("inlineCode",{parentName:"p"},"ArrayBuffer"),"s as the number of input RDDs. So in the example we have 2 ",(0,i.kt)("inlineCode",{parentName:"p"},"ArrayBuffers")," in each task. When a key-value pair comes from RDD A, we add it to the first ",(0,i.kt)("inlineCode",{parentName:"p"},"ArrayBuffer"),". If a key-value pair comes from RDD B, then it goes to the second ",(0,i.kt)("inlineCode",{parentName:"p"},"ArrayBuffer"),". Finally a ",(0,i.kt)("inlineCode",{parentName:"p"},"mapValues()")," operation transforms the values into the correct type: ",(0,i.kt)("inlineCode",{parentName:"p"},"(ArrayBuffer, ArrayBuffer)")," => ",(0,i.kt)("inlineCode",{parentName:"p"},"(Iterable[V], Iterable[W])"),"."),(0,i.kt)("h3",{id:"intersectionotherrdd-and-joinotherrdd-numpartitions"},(0,i.kt)("inlineCode",{parentName:"h3"},"intersection(otherRDD)")," and ",(0,i.kt)("inlineCode",{parentName:"h3"},"join(otherRDD, numPartitions)")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"intersection",src:a(5902).Z,width:"1660",height:"852"})),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"join",src:a(2824).Z,width:"1652",height:"927"})),(0,i.kt)("p",null,"This two operations both use ",(0,i.kt)("inlineCode",{parentName:"p"},"cogroup"),", so their shuffle process is identical to ",(0,i.kt)("inlineCode",{parentName:"p"},"cogroup"),"."),(0,i.kt)("h3",{id:"sortbykeyascending-numpartition"},"sortByKey(ascending, numPartition)"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"sortByKey",src:a(7020).Z,width:"490",height:"284"})),(0,i.kt)("p",null,"The processing logic of ",(0,i.kt)("inlineCode",{parentName:"p"},"sortByKey()")," is a little different from ",(0,i.kt)("inlineCode",{parentName:"p"},"reduceByKey()")," as it does not use a ",(0,i.kt)("inlineCode",{parentName:"p"},"HashMap")," to handle incoming fetched records. Instead, all key-value pairs are range partitioned. The records of the same partition is sorted by key."),(0,i.kt)("h3",{id:"coalescenumpartitions-shuffle--true"},(0,i.kt)("inlineCode",{parentName:"h3"},"coalesce(numPartitions, shuffle = true)")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Coalesce",src:a(2062).Z,width:"1585",height:"791"})),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"coalesce()")," would create a ",(0,i.kt)("inlineCode",{parentName:"p"},"ShuffleDependency"),", but it actually does not need to aggregate the fetched records, so no hash map is needed."),(0,i.kt)("h2",{id:"hashmap-in-shuffle-read"},"HashMap in Shuffle Read"),(0,i.kt)("p",null,"So as we have seen, hash map is a frequently used data structure in Spark's shuffle process. Spark has 2 versions of specialized hash map: in memory ",(0,i.kt)("inlineCode",{parentName:"p"},"AppendOnlyMap")," and memory-disk hybrid ",(0,i.kt)("inlineCode",{parentName:"p"},"ExternalAppendOnlyMap"),". Let's look at some details of these two hash map implementations."),(0,i.kt)("h3",{id:"appendonlymap"},(0,i.kt)("inlineCode",{parentName:"h3"},"AppendOnlyMap")),(0,i.kt)("p",null,"The Spark documentation describes ",(0,i.kt)("inlineCode",{parentName:"p"},"AppendOnlyMap"),' as "A simple open hash table optimized for the append-only use case, where keys are never removed, but the value for each key may be changed". Its implementation is simple: allocate a big array of ',(0,i.kt)("inlineCode",{parentName:"p"},"Object"),", as the following diagram shows. Keys are stored in the blue sections, and values are in the white sections."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"AppendOnlyMap",src:a(9790).Z,width:"1447",height:"656"})),(0,i.kt)("p",null,"When a ",(0,i.kt)("inlineCode",{parentName:"p"},"put(K, V)")," is issued, we locate the slot in the array by ",(0,i.kt)("inlineCode",{parentName:"p"},"hash(K)"),". ",(0,i.kt)("strong",{parentName:"p"},"If the position is already occupied, then quadratic probing technique is used to find the next slot."),". For the example in the diagram, ",(0,i.kt)("inlineCode",{parentName:"p"},"K6"),", a third probing has found an empty slot after ",(0,i.kt)("inlineCode",{parentName:"p"},"K4"),", then the value is inserted after the key. When ",(0,i.kt)("inlineCode",{parentName:"p"},"get(K6)"),", we use the same technique to find the slot, get ",(0,i.kt)("inlineCode",{parentName:"p"},"V6")," from the next slot, compute a new value, then write it to the position of ",(0,i.kt)("inlineCode",{parentName:"p"},"V6"),"."),(0,i.kt)("p",null,"Iteration over the ",(0,i.kt)("inlineCode",{parentName:"p"},"AppendOnlyMap")," is just a scan of the array."),(0,i.kt)("p",null,"If 70% of the allocated array is used, then it will grow twice as large. Keys will be rehashed and the positions re-organized."),(0,i.kt)("p",null,"There's a ",(0,i.kt)("inlineCode",{parentName:"p"},"destructiveSortedIterator(): Iterator[(K, V)]")," method in ",(0,i.kt)("inlineCode",{parentName:"p"},"AppendOnlyMap"),". It returns sorted key-value pairs. It's implemented like this: first compact all key-value pairs to the front of the array and make each key-value pair in a single slot. Then ",(0,i.kt)("inlineCode",{parentName:"p"},"Array.sort()")," is called to sort the array. As its name indicates, this operation will destroy the structure."),(0,i.kt)("h3",{id:"externalappendonlymap"},(0,i.kt)("inlineCode",{parentName:"h3"},"ExternalAppendOnlyMap")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"AppendOnlyMap",src:a(1005).Z,width:"1714",height:"2816"})),(0,i.kt)("p",null,"Compared with ",(0,i.kt)("inlineCode",{parentName:"p"},"AppendOnlyMap"),", the implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"ExternalAppendOnlyMap")," is more sophisticated. Its concept is similar to the ",(0,i.kt)("inlineCode",{parentName:"p"},"shuffle-merge-combine-sort")," process in Hadoop."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"ExternalAppendOnlyMap")," holds an ",(0,i.kt)("inlineCode",{parentName:"p"},"AppendOnlyMap"),". Incoming key-value pairs are inserted into the ",(0,i.kt)("inlineCode",{parentName:"p"},"AppendOnlyMap"),". ",(0,i.kt)("strong",{parentName:"p"},"When ",(0,i.kt)("inlineCode",{parentName:"strong"},"AppendOnlyMap")," is about to grow its size, we'll check the available memory space. If there's still enough space, the ",(0,i.kt)("inlineCode",{parentName:"strong"},"AppendOnlyMap")," doubles its size, otherwise all its key-value pairs are sorted and then spilled onto local disk (by using ",(0,i.kt)("inlineCode",{parentName:"strong"},"destructiveSortedIterator()"),").")," In the diagram, there're 4 spills of this map. In each spill, a ",(0,i.kt)("inlineCode",{parentName:"p"},"spillMap")," file will be generated and a new, empty ",(0,i.kt)("inlineCode",{parentName:"p"},"AppendOnlyMap")," will be instantiated to receive incoming key-value pairs. In ",(0,i.kt)("inlineCode",{parentName:"p"},"ExternalAppendOnlyMap"),", when a key-value pair is inserted, it gets aggregated only with the in memory part (the ",(0,i.kt)("inlineCode",{parentName:"p"},"AppendOnlyMap"),"). So it means when asked for the final result, a global merge-aggregate needs to be performed on all spilled maps and the in memory ",(0,i.kt)("inlineCode",{parentName:"p"},"AppendOnlyMap"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Global merge-aggregate runs as follows.")," Firstly the in memory part (",(0,i.kt)("inlineCode",{parentName:"p"},"AppendOnlyMap"),") is sorted to a ",(0,i.kt)("inlineCode",{parentName:"p"},"sortedMap"),". Then ",(0,i.kt)("inlineCode",{parentName:"p"},"DestructiveSortedIterator")," (for ",(0,i.kt)("inlineCode",{parentName:"p"},"sortedMap"),") or ",(0,i.kt)("inlineCode",{parentName:"p"},"DiskMapIterator")," (for on disk ",(0,i.kt)("inlineCode",{parentName:"p"},"spillMap"),") will be used to read a part of the key-value pairs into a ",(0,i.kt)("inlineCode",{parentName:"p"},"StreamBuffer"),". Then the ",(0,i.kt)("inlineCode",{parentName:"p"},"StreamBuffer")," is inserted into a ",(0,i.kt)("inlineCode",{parentName:"p"},"mergeHeap"),". In each ",(0,i.kt)("inlineCode",{parentName:"p"},"StreamBuffer"),", all records have the same ",(0,i.kt)("inlineCode",{parentName:"p"},"hash(key)"),". Suppose that in the example, we have ",(0,i.kt)("inlineCode",{parentName:"p"},"hash(K1) == hash(K2) == hash(K3) < hash(K4) < hash(K5)"),". As a result, the first 3 records of the first spilled map are read into the same ",(0,i.kt)("inlineCode",{parentName:"p"},"StreamBuffer"),". The merge is simple: get ",(0,i.kt)("inlineCode",{parentName:"p"},"StreamBuffer"),"s with the same key hash using a heap, then put them into an ",(0,i.kt)("inlineCode",{parentName:"p"},"ArrayBuffer[StreamBuffer]"),"(",(0,i.kt)("inlineCode",{parentName:"p"},"mergedBuffers"),") for merge. The first inserted ",(0,i.kt)("inlineCode",{parentName:"p"},"StreamBuffer")," is called ",(0,i.kt)("inlineCode",{parentName:"p"},"minBuffer"),", the key of its first key-value pair is ",(0,i.kt)("inlineCode",{parentName:"p"},"minKey"),". One merge operation will aggregate all KV pairs with ",(0,i.kt)("inlineCode",{parentName:"p"},"minKey")," in the ",(0,i.kt)("inlineCode",{parentName:"p"},"mergedBuffer")," and then output the result. When a merge operation in ",(0,i.kt)("inlineCode",{parentName:"p"},"mergedBuffer")," is over, remaining KV pairs will return to the ",(0,i.kt)("inlineCode",{parentName:"p"},"mergeHeap"),", and empty ",(0,i.kt)("inlineCode",{parentName:"p"},"StreamBuffer")," will be replaced by a new read from in-memory map or on-disk spill."),(0,i.kt)("p",null,"There're still 3 points needed to be discussed:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Available memory check. Hadoop allocates 70% of the memory space of a reducer for shuffle-sort. Similarly, Spark has ",(0,i.kt)("inlineCode",{parentName:"p"},"spark.shuffle.memoryFraction * spark.shuffle.safetyFraction")," (defaults to 0.3 * 0.8) for ",(0,i.kt)("inlineCode",{parentName:"p"},"ExternalAppendOnlyMap"),". ",(0,i.kt)("strong",{parentName:"p"},"It seems that Spark is more conservative. Moreover, this 24% of memory space is shared by all reducers in the same executor.")," An executor holds a ",(0,i.kt)("inlineCode",{parentName:"p"},"ShuffleMemoryMap: HashMap[threadId, occupiedMemory]")," to monitor memory usage of all ",(0,i.kt)("inlineCode",{parentName:"p"},"ExternalAppendOnlyMap"),"s in each reducer. Before an ",(0,i.kt)("inlineCode",{parentName:"p"},"AppendOnlyMap")," grows, the total memory usage after the growth will be computed using the information in ",(0,i.kt)("inlineCode",{parentName:"p"},"ShuffleMemoryrMap"),", to see if there's enough space. Also notice that the first 1000 records will not trigger the spill check.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"AppendOnlyMap")," size estimation. To know the size of an ",(0,i.kt)("inlineCode",{parentName:"p"},"AppendOnlyMap"),", we can compute the size of every object referenced in the structure during each growth. But this takes too much time. Spark has an estimation algorithm with O(1) complexity. Its core concept is to see how the map size changes after the insertion and aggregation of a certain amount of records to estimate the structure size. Details are in ",(0,i.kt)("inlineCode",{parentName:"p"},"SizeTrackingAppendOnlyMap")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"SizeEstimator"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Spill process. Like the shuffle write, Spark creates a buffer when spilling records to disk. Its size is ",(0,i.kt)("inlineCode",{parentName:"p"},"spark.shuffle.file.buffer.kb"),", defaulting to 32KB. Since the serializer also allocates buffers to do its job, there'll be problems when we try to spill lots of records at the same time. Spark limits the records number that can be spilled at the same time to ",(0,i.kt)("inlineCode",{parentName:"p"},"spark.shuffle.spill.batchSize"),", with a default value of 10000."))),(0,i.kt)("h2",{id:"discussion"},"Discussion"),(0,i.kt)("p",null,"As we've seen in this chapter, Spark is way more flexible in the shuffle process compared to Hadoop's fixed shuffle-combine-merge-reduce model. It's possible in Spark to combine different shuffle strategies with different data structures to design an appropriate shuffle process based on the semantic of the actual transformation."),(0,i.kt)("p",null,"So far we've discussed the shuffle process in Spark without sorting as well as how this process gets integrated into the actual execution of the RDD chain. We've also talked about memory and disk issues and compared some details with Hadoop. In the next chapter we'll try to describe job execution from an inter-process communication perspective. The shuffle data location problem will also be mentioned."),(0,i.kt)("p",null,"Plus to this chapter, thers's the outstanding blog (in Chinese) by Jerry Shao, ",(0,i.kt)("a",{parentName:"p",href:"http://jerryshao.me/2014/01/04/spark-shuffle-detail-investigation/"},"Deep Dive into Spark's shuffle implementation"),"."))}u.isMDXComponent=!0},1005:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/ExternalAppendOnlyMap-c09c623252fde527e8ba396216a72939.png"},1787:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/ShuffleCoGroup-d292dfea7e761e20a93db029031acdd2.png"},2062:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/ShuffleCoalesce-201159fefbf6bb73036a0fc88af9cd9f.png"},2855:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/ShuffleDistinct-1f360f91fc85645a0183f38595cf3fc3.png"},8801:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/ShuffleGroupByKey-56d9b95d0d8977f6452c5aae07c9282e.png"},5902:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/ShuffleIntersection-ac7cce7075bf9c580b3a710293fcc0cc.png"},2824:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/ShuffleJoin-95b56d52ad5cfd95e3511d3419c78bbd.png"},7020:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/ShuffleSortByKey-3ddfdb9c94b2aa4723c64d391fc624ec.png"},9790:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/appendonlymap-bc4a365084f857c31a6c55eb67924799.png"},9018:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/reduceByKeyRecord-6e3b1d9208b53372e8d12d7362c90ce5.png"},3721:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/reduceByKeyStage-80d81b3cca5c75832e26936ec40e4caa.png"},4360:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/shuffle-write-consolidation-5093d2e3c7affa1e7bc4cafa1036b8e7.png"},8343:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/shuffle-write-no-consolidation-df8e2a45cd3d74f6137a289da02ee871.png"}}]);